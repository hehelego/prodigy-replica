\documentclass[a4paper]{article}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{xcolor}
\usepackage{syntax}
\usepackage{stmaryrd}
\usepackage[backend=biber]{biblatex}
\addbibresource{ref.bib}

\title{Final Report\\
	\small Verifying Output Distribution Equivalence for Rectangular Discrete Probabilistic Programs via the PGF transformer semantics
}
\date{Finished on \today}
\author{Cheng Peng (2020533068)}

\DeclareMathOperator*{\PGF}{PGF}
\DeclareMathOperator*{\SOP}{SOP}
\DeclareMathOperator*{\VARS}{Var}
\DeclareMathOperator*{\PARMS}{Parm}
\DeclareMathOperator*{\iid}{iid}
\DeclareMathOperator*{\lfp}{fix}
\renewcommand{\S}[1]{ \llbracket #1 \rrbracket }

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{remark}[theorem]{Remark}

\begin{document}

\maketitle

\begin{abstract}
	Randomized behavior is ubiquitous and inevitable in real-world programs, especially in certain security-critical domains like cryptography and cyber-physics systems.
	However, the lack of the efficient algorithms and data structures for representing and manipulating distributions makes it difficult to automatically verify the correctness of probabilistic programs.
	Traditional methods are only capable of computing digests of probability distributions, e.g., the expectation and variance, which are insufficient.\par
	Recently, the MOVES research team headed by Prof. Katoen Joost-Pieter at RWTH Aachen proposed probability generating function transformer semantics of probabilistic programs and devised automated verification techniques based the semantics.
	This novel approach preserves the entire distribution carried by programs, enabling precise reasoning about the behavior of probabilistic programs.\par
	In this course project, we investigate the theoretical foundation of the aforementioned approach, the PGF transformer semantics, and develop proof-of-concept tools that can verify a simple program generates exactly the desired distribution.
\end{abstract}

\section{Introduction}

\subsection{Motivation}

\begin{itemize}
	\item Randomness is pervasive, arising naturally and inevitably in certain context.
	      For example, applications interacting with the physical world have to handle noisy input.
	      Models of crowd dynamics often involves non-deterministic motions.
	      Furthermore, randomness is a key to efficient algorithms and data structure.
	\item Probabilistic programs often function as the key component of security-critical systems,
	      for example, cryptograpy libraries are bedrock of online banking systems.
	      Therefore, it is necessary to verify the correctness of probabilistic programs.
	\item It is common to require that the output distribution of a program matches exactly with a pre-determined distribution.
	      Unaware of tiny deviation from the desired distribution may lead to side-channel leak or introduce vulnerabilites.
	      Previous approaches focusing on deriving expecation or establishing bounds are thus insufficient,
	      since they are not sensitive to small perturbations.
\end{itemize}

% Randomness arises naturally when modeling the physics processes and are of special interest in various fields such as approximate algorithms and fair scheduling. Probabilistic programming has been a hot-spot of research in recent years. Many researchers are working on providing correctness grantee for probabilistic programs.\\
% The research team lead by Prof. Katoen Joost-Pieter at RWTH Aachen proposed a unified framework for automated verification and inference of probabilistic programs. They devised denotational semantics of probabilistic programs on probability generating functions, and developed automated tools for computing PGF transformers of probabilistic programs.

% The main idea of their approach is demonstrated in \cite{cav-pgf}, which focuses on computing the exact distribution of the output of a probabilistic program. Followed by this paper, \cite{OOPSLA2024-inf-loop} and \cite{lafi-inf} extended the technique to automated Bayesian inference.
% To comprehend their research work, one need familiarity with generating functions, which can be obtained from \cite{gfbook}.

\subsection{Overview}

% introduce the framework of PRODIGY
% what we are trying to answer
% the input languages
% the output languages
% the checking algorithm key idea
In this project, we reimplemented the PRODIGY verifier.

\begin{description}
	\item[??] ?
\end{description}

\section{The ReDiP Programming Language}

% put the pGCL syntax here
\subsection{The pGCL programming language}

% give a few examples demonstrating the power of pGCL.

\subsection{Execution Tree Based Operational Semantics}

\subsection{Restrictions on pGCL}

\section{PGF transformer semantics of ReDiP}

\subsection{Review on Probability Generating Functions (PGFs)}

\subsubsection{definitions and forms}

1D formal power series:

\[
	f = \sum_{i=0}^\infty f_i x^i
\]

This can be extended to 2D scenario:

\[
	f = \sum_{i=0}^\infty\sum_{j=0}^\infty f_{i,j} x^i y^j
\]

And even \(k\in\mathbb{N}\) dimension, for indeterminate \(\mathbb{X}=(X_1,X_2,\ldots,X_k)\):

\[
	f = \sum_{\sigma\in\mathbb{N}^k} f(\sigma) \mathbf{X}^\sigma
	\quad
	f:\mathbb{N}^k\to\mathbb{R},
	X^\sigma = \prod_{i=1}^k X_i^{\sigma_i}
\]

Rational PGFs: for \(n,m\in\mathbb{N}\),

\[
	g = \frac{\sum_{i=0}^n A_i X^i}{\sum_{j=0}^m B_j X^j}
\]

If a formal power series is the Taylor series of a rational function, we say that it is in closed form.

\subsubsection{operations}

The PGF of random vector \(\mathbf{X} = (X_1,X_2,\ldots X_k)\) is defined as

\[
	g = \mathbb{E} \exp\left( t_1^{X_1} t_2^{X_2} \ldots t_k^{X_k} \right)
\]

Consider the operation \(g[X_i/0]\) to set \(X_i=0\)

\[
	g[X_i/0] = \mathbb{E} \exp\left( t_1^{X_1} \ldots t_i^{0} \ldots t_k^{X_k} \right)
\]

The operation \(g X_i^n\) to set \(X_i \gets X_i + n\)

\[
	g X_i^n = \mathbb{E} \exp\left( t_1^{X_1} \ldots t_i^{(X_i+n)}\ldots t_k^{X_k} \right)
\]

Suppose that we have a random variable \(Y\) whose PGF is \(h = \mathbb{E}(t^Y)\) then. Essentially setting \(X_i \gets X_i + Y\).

\[
	g h[t/t_i] = \mathbb{E} \exp\left( t_1^{X_1} \ldots t_i^{(X_i+Y)}\ldots t_k^{X_k} \right)
\]

Further more, say that we draw \(X_i\) iid samples from a distribution \(\mathbf{D}\) of PGF \(h(t)\), then. That is to set \(X_i \gets X_i + \iid(D, X_j)\)

\[
	g[t_j / (t_j h[t/t_i])] = 
	\mathbb{E} \exp\left( t_1^{X_1} \ldots t_i^{X_i} h(t_i)^{X_j} \cdot t_j^{X_j}\ldots t_k^{X_k} \right)
\]

\subsection{Distribution transformation of ReDiP}

\begin{theorem}{closed form preservation of ReDiP}
	For a loop-free ReDiP program, and a rational PGF \(f/g\),
	\(\S{P}(f/g)\) is also a rational PGF.
\end{theorem}
\begin{proof}
	By induction on the program structure.
\end{proof}

\section{Verifying Equivalence of linear PGF transformers}

\section{Evaluation}

\subsection{Experiment setup}

\subsection{Results}

\section{Discussion}

\subsection{Limitation of the approach}

\subsection{State of the method}

\subsection{Future research work}

\subsection{Related works}

\appendix
\setlength{\parskip}{0pt}
\printbibliography

\end{document}
